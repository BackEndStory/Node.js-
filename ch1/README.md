# Node.js-DesignPatternBibble

⚄ Node.js는 패키지 관리자(npm, yarn)의 도움을 받아 각 패키지가 자신이 필요로 하는 버전의 종속성 패키지들을 갖도록 함으로써 종속성 지옥에서 벗어나게 해준다.<br>
<h4>DRY원칙</h4>
- 이해하기 쉽고 사용하기 쉽다.
- 테스트 및 유지보수가 쉽다.
- 사이즈가 작아 브라우저에서 사용하기에는 완벽하다.

<h1>Node.js는 어떻게 작동하는가?</h1>

<h3>블로킹 I/O</h3>
I/O를 요청하는 함수의 호출은 작업이 완료될 때까지 스레드의 실행을 차단한다.<br>
=> 여러 연결을 처리하지 못함<br>
=> 해결하기 위해서는 개별의 스레드(자바) 또는 프로세스를 사용한다.<br>

![KakaoTalk_Photo_2023-07-19-22-32-22 002](https://github.com/BackEndStory/Node.js-DesignPartternBibble/assets/106163272/435ce3c5-462a-4383-990e-452385c887ac)

자바의 다중 스레드와 같은 그림이다.(요청 당 하나의 스레드가 관여한다.)<br>
스레드는 시스템 리소스 측면에서 비용이 저렴하지 않다. 메모리를 소모하고 컨텍스트 전환을 유발하여 대부분의 시간 동안 사용하지 않는 장시간 실행 스레드를 가지게 됨으로써<br>
귀중한 메모리와 CPU 사이클을 낭비하게 된다.<br>
=> 여러 스레드가 CPU에서 문맥교환(컨텍스트 교환)을 통해 연산을 처리함<br><br>
<h3>논 블로킹 I/O</h3>
운영모드에서 시스템 호출은 데이터가 읽혀지거나 쓰여지기를 기다리지 않고 즉시 반환한다.<br><br>

논 블로킹 I/O 알고리즘<br>
![KakaoTalk_Photo_2023-07-19-22-32-22 001](https://github.com/BackEndStory/Node.js-DesignPartternBibble/assets/106163272/b792782f-dab8-49f6-8492-af1a72533315)



1. 폴링 알고리즘<br>
   - 실제 데이터가 반환될 때까지 루프 내에서 리소스를 적극적으로 폴링하는 것이다.(바쁜 대기)
   - 특정 조건이 충족될 때까지 반복적으로 상태를 확인하고, 조건이 충족될 때 적절한 동작을 수행합니다.
   - 주기적으로 서버로 데이터를 요청하여 변경사항이 있는지 확인하거나, 일정 간격으로 API를 호출하여 업데이트된 데이터를 가져오는 것이 폴링 방식의 예입니다. 폴링 방식은 미리 정의된 시간 간격 또는 주기에 따라 데이터를 감시하고 처리하는데 사용됩니다. 주기적으로 루프를 돌면서 데이터의 상태를 확인하기 때문에 계속해서 CPU 자원을 사용하게 됩니다.
  
   수행 단계<br>
   1.상태를 검사하고자 하는 조건을 설정합니다.<br>
   2.조건이 충족될 때까지 반복문을 실행하여 주기적으로 조건을 체크합니다.<br>
   3.조건이 충족되면 해당 동작을 수행합니다.<br>
   4.조건이 아직 충족되지 않았다면 다시 반복하여 조건을 체크합니다.<br><br>

   
2. 이벤트 디멀티플렉싱(동기 이벤트 디멀티플렉서 또는 이벤트 통지 인터페이스)<br>

   
  - 이벤트 루프란 : <br>
      자바스크립트는 단일 스레드에서 동작하므로, 이벤트 루프를 통해 비동기적으로 처리되어야 하는 작업을 관리합니다. <br>
      이벤트 루프는 콜 스택(Call Stack), 백그라운드 (Background), 태스크 큐(Task Queue) 등의 컴포넌트들로 이루어져 있습니다.<br>
  - 이벤트 루프 순환 방식 : <br>
     이벤트 루프는 비동기 이벤트를 처리하는 메커니즘으로서, 이벤트를 계속 감시하면서 콜 스택에 머무르는 작업이 없다면 태스크 큐에 있는 이벤트를 콜 스택으로 옮겨 실행합니다. <br>
  이때 이벤트 디멀티플렉싱을 통해 이벤트가 발생하기 전까지 블로킹된 상태가 아닌 이벤트 처리 가능한 상태를 유지합니다. <br>
  즉, 이벤트 루프는 계속해서 이벤트를 감시하고, 콜 스택이 비어있을 때만 이벤트를 처리하기 때문에 다른 작업을 블로킹하지 않고 비동기적으로 작업을 처리할 수 있습니다.<br>
이렇게 이벤트 루프를 통해 자바스크립트는 비동기적으로 동작하면서 블로킹을 최소화하여 더 효율적인 프로그래밍 환경을 제공합니다. <br>
비동기 프로그래밍을 통해 여러 작업들이 동시에 처리될 수 있으며, 사용자 경험을 향상시키고 응답성을 높일 수 있습니다.<br><br>



 - 이벤트 디멀티플렉싱 개념 : <br>
   이벤트 디멀티플렉싱은 이벤트가 발생할 때까지 대기하다가, 이벤트가 발생하면 해당 이벤트를 처리하는 방식입니다.<br>
이벤트 디멀티플렉싱은 보통 이벤트 루프(Event Loop)와 결합되어 사용됩니다. 이벤트 루프는 프로그램이 이벤트를 감시하고 대기하는 상태에서 다른 작업을 처리하도록 합니다.<br>
이벤트 디멀티플렉싱은 비동기적으로 작업을 수행할 때 주로 사용되며, 콜백 함수 또는 프로미스와 같은 방법을 통해 이벤트가 발생했을 때 처리되어야 하는 로직을 정의할 수 있습니다. <br>
이벤트 디멀티플렉싱은 CPU 자원을 효율적으로 사용하면서 이벤트가 발생할 때만 처리를 진행하기 때문에 폴링 방식보다 더 효율적입니다.<br>

<h3>리액터 패턴</h3>
![KakaoTalk_Photo_2023-07-19-22-32-23 004](https://github.com/BackEndStory/Node.js-DesignPartternBibble/assets/106163272/d45a830c-4492-48e9-a39a-cf9c4a77a6e0)
그림에서 이벤트 큐가 태스크 큐의 일종이다 (같은 개념이다.)<br>

1. 애플리케이션은 이벤트 디멀티플렉서에 요청을 전달함으로써 새로운 I/O 작업을 생성. 또한, 애플리케이션은 작업이 완료됐을 때 호출될 핸들러를 명시.<br>
   이벤트 디멀티플렉서에 새 요청을 전달하는 것은 논 블로킹 호출이며, 제어권은 애플리케이션으로 즉시 반환.<br>
2. 일련의 I/O 작업들이 완료되면 이벤트 디멀티플렉서는 대응하는 이벤트 작업들을 이벤트 큐에 집어넣는다.<br>
3. 이 시점에서 이벤트 루프가 이벤트 큐의 항목들을 순환<br>
4. 각 이벤트와 관련된 핸들러가 호출됨.<br>
5. 애플리케이션 코드의 일부인 핸들러의 실행이 완료되면 제어권을 이벤트 루프에 되돌려준다.(5a)<br>
   핸들러 실행 중에 다른 비동기 작업을 요청할 수 있으며(5b) 이는 이벤트 디멀티플렉서에 새로운 항목을 추가한다.<br>
6. 이벤트 큐의 모든 항목이 처리되고 나면 이벤트 루프는 이벤트 디멀티플렉서에서 블로킹되며 처리 가능한 새 이벤트가 있을 경우 이 과정이 다시 트리거가 됨.<br><br>

<h3>Node.js를 위한 구성</h3>

libuv : 운영체제마다 환경이 달라 불일치성이 나온다. 이로 인해 주요 운영체제에서 호환되게 해주며 서로 다른 리소스 유형의 논 블로킹 동작을 표준화하기 위해 libuv라고 불리는 C 라이브러리를 만들었다.<br>
 바인딩 : libuvd와 다른 저수준들을 랩핑하고 표출시키기 위한 바인딩 세트<br>
 V8  : 크롬 브라우저를 위해 구글이 개발한 자바스크립트엔진으로 Node.js가 매우 빠르고 효율적인 이유 중 하나이다. V8은 혁신적인 설계 속도 그리고 효율적인 메모리 관리로 높은 평가를 받는다.<br>
 코어 자바스크립트 API : 고수준 Node.js API를 구현하고 있는 코어 JavaScript 라이브러리<br>

 
 




   

   
   










